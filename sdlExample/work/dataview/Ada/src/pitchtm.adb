pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");
pragma Warnings (On, "redundant with clause in body");

package body PitchTM with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccPITCH_VALUE_Equal (val1, val2 :  asn1SccPITCH_VALUE) return Boolean
is

begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end asn1SccPITCH_VALUE_Equal;

function asn1SccPITCH_VALUE_Init return asn1SccPITCH_VALUE
is
    val: asn1SccPITCH_VALUE;
begin
    val := 0.0000000000000000000E+000;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPITCH_VALUE_Init;

function asn1SccPITCH_VALUE_IsConstraintValid(val : asn1SccPITCH_VALUE) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := ((-9.0000000000000000000E+001 <= val) AND (val <= 9.0000000000000000000E+001));
    ret.ErrorCode := (if ret.Success then 0 else ERR_PITCH_VALUE);
    return ret;
end asn1SccPITCH_VALUE_IsConstraintValid;



function asn1SccRESOLUTION_Equal (val1, val2 :  asn1SccRESOLUTION) return Boolean
is

begin
	return val1 = val2;

end asn1SccRESOLUTION_Equal;

function asn1SccRESOLUTION_Init return asn1SccRESOLUTION
is
    val: asn1SccRESOLUTION;
begin
    val := 10;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccRESOLUTION_Init;

function asn1SccRESOLUTION_IsConstraintValid(val : asn1SccRESOLUTION) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := ((10 <= val) AND (val <= 16));
    ret.ErrorCode := (if ret.Success then 0 else ERR_RESOLUTION);
    return ret;
end asn1SccRESOLUTION_IsConstraintValid;



function asn1SccVALIDITY_Equal (val1, val2 :  asn1SccVALIDITY) return Boolean
is

begin
	return val1 = val2;

end asn1SccVALIDITY_Equal;

function asn1SccVALIDITY_Init return asn1SccVALIDITY
is
    val: asn1SccVALIDITY;
begin
    val := asn1Sccvalid;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccVALIDITY_Init;

function asn1SccVALIDITY_IsConstraintValid(val : asn1SccVALIDITY) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccvalid)) OR ((val = asn1Sccinvalid)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_VALIDITY);
    return ret;
end asn1SccVALIDITY_IsConstraintValid;



function asn1SccPITCH_SEQ_Equal (val1, val2 :  asn1SccPITCH_SEQ) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.pitchVal, val2.pitchVal));

    if ret then
        ret := (val1.res = val2.res);

        if ret then
            ret := (val1.vali = val2.vali);

        end if;
    end if;
	return ret;

end asn1SccPITCH_SEQ_Equal;

function asn1SccPITCH_SEQ_Init return asn1SccPITCH_SEQ
is
    val: asn1SccPITCH_SEQ;
begin

    --set pitchVal 
    val.pitchVal := asn1SccPITCH_VALUE_Init;
    --set res 
    val.res := asn1SccRESOLUTION_Init;
    --set vali 
    val.vali := asn1SccVALIDITY_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPITCH_SEQ_Init;

function asn1SccPITCH_SEQ_IsConstraintValid(val : asn1SccPITCH_SEQ) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccPITCH_VALUE_IsConstraintValid(val.pitchVal);
    if ret.Success then
        ret := asn1SccRESOLUTION_IsConstraintValid(val.res);
        if ret.Success then
            ret := asn1SccVALIDITY_IsConstraintValid(val.vali);
        end if;
    end if;
    return ret;
end asn1SccPITCH_SEQ_IsConstraintValid;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end PitchTM;